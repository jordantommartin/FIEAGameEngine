#pragma once
#include <gsl/gsl>
#include "HashMap.h"

namespace FIEAGameEngine
{
	/// <summary>
	/// Abstract factory class used to enable to "factory" design pattern on any interface class that has a default constructor. 
	/// Also doubles as a manager class that holds and manages all existing derived factories.
	/// </summary>
	/// <typeparam name="T">The type of class that you are creating a factory for. This is also the type of object that this factory will generate.</typeparam>
	template <typename T>
	class Factory
	{
	public:
		/// <summary>
		/// Returns the class name of the classes that this factory generates.
		/// Intended to be overriden by each derived class.
		/// </summary>
		/// <returns>Class name of the type of factory</returns>
		virtual const std::string& ClassName() const = 0;
		/// <summary>
		/// Returns a new object of the type that this factory generates.
		/// </summary>
		/// <returns>The newly created object that this factory can generate.</returns>
		virtual gsl::owner<T*> Create() const = 0;
		/// <summary>
		/// Static function that allows you to create a type of the class name that was passed in.
		/// Finds the factory the factory for that type and calls its own create method.
		/// The factory must have already been created in order to call create on that type of object.
		/// </summary>
		/// <param name="className">The name of the class that you want to generate an object of.</param>
		/// <returns></returns>
		static gsl::owner<T*> Create(const std::string& className);
		/// <summary>
		/// Checks if the static hashmap of factories is empty.
		/// </summary>
		/// <returns>Whether the amount of factories is zero.</returns>
		static bool IsEmpty();
		/// <summary>
		/// Returns the number of factories that is in the static hashmap of factories.
		/// </summary>
		/// <returns>The size of the static hashmap of factories.</returns>
		static size_t Size();

		/// <summary>
		/// Finds the factory that generates objects of the class name that is provided.
		/// Returns nullptr if the factory was not found.
		/// </summary>
		/// <param name="className">The name of the class that is generated by the factory you are searching.</param>
		/// <returns>A pointer to the factory that was found using the class name or nullptr</returns>
		static const Factory* const Find(const std::string& className);

	protected:
		/// <summary>
		/// Adds an existing factory reference to the static hashmap of factories.
		/// </summary>
		/// <param name="factory">The factory you want to add to the manager.</param>
		static void Add(const Factory& factory);
		/// <summary>
		/// Removes an existing factory reference from the static hashmap of factories.
		/// </summary>
		/// <param name="factory">The factory you want to remove from the manager.</param>
		static void Remove(const Factory& factory);

	private:
		/// <summary>
		/// The static hashmap used to store all the types of factories in this manager.
		/// </summary>
		inline static HashMap<std::string, const Factory* const> _factories;
	};

/// <summary>
/// The macro that is used to create derived classes of Factory.
/// </summary>
#define ConcreteFactory(ConcreteProductT, AbstractProductT)														\
	class ConcreteProductT##Factory final : public FIEAGameEngine::Factory<AbstractProductT>					\
	{																											\
	public:																										\
		ConcreteProductT##Factory() { Add(*this); }																\
		~ConcreteProductT##Factory() { Remove(*this); }															\
		const std::string& ClassName() const override { return _className; }									\
		gsl::owner<ConcreteProductT*> Create() const override { return new ConcreteProductT(); }				\
	private:																									\
		inline static const std::string _className{ #ConcreteProductT };										\
	};																											\

}

#include "Factory.inl"